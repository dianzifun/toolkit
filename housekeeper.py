#!/usr/bin/env python

# One script to manage my important collections.
#
# Author: Santa Zhang (santa1987@gmail.com)
#

import sys
import os
import re
import time
import random
import shutil
import traceback
from utils import *

def hk_make_dirs(path):
  if os.path.exists(path) == False:
    print "[mkdir] %s" % path
    os.makedirs(path)

def hk_exec(cmd):
  print "[cmd] %s" % cmd
  os.system(cmd)

def hk_read_crc32_dict(crc32_dict_fn):
  crc32_dict = {}
  if os.path.exists(crc32_dict_fn):
    f = open(crc32_dict_fn)
    for line in f.readlines():
      line = line.strip()
      if line.startswith(";") or line.startswith("#") or line == "":
        continue
      idx = line.find(" ")
      if idx < 0:
        continue
      crc32_dict[line[(idx + 1):]] = line[:idx]
    f.close()
  return crc32_dict

# if return None, then no info
# first try to get data from dict
# if not found, then get data from fname
def hk_try_get_crc32_info(fname, crc32_dict):
  if crc32_dict.has_key(fname):
    return crc32_dict[fname]
  splt = re.split("\[|\]|\(|\)|_", fname)
  for sp in splt:
    if len(sp) == 8 and is_hex(sp):
      return sp
  return None

def hk_calc_crc32_from_file(crc32_bin, fpath):
  crc = None
  cmd = "%s \"%s\"" % (crc32_bin, fpath)
  pipe = os.popen(cmd)
  crc = pipe.readlines()[0].split()[0]
  pipe.close()
  if crc == None:
    raise Exception("Failed to calc crc32 for '%s'! Binary is '%s'." % (fpath, crc32_bin))
  return crc

def hk_check_crc32_walker(crc32_bin, folder, files):
  write_log("[dir] %s" % folder)
  crc32_dict_fn = folder + os.path.sep + "housekeeper.crc32"
  crc32_dict = hk_read_crc32_dict(crc32_dict_fn)
  if os.path.exists(crc32_dict_fn):
    write_log("[dict] %s" % crc32_dict_fn)
    
  for fn in files:
    if fn.startswith("housekeeper."):
      # ignore housekeeper's data
      continue
    fpath = folder + os.path.sep + fn
    if os.path.isdir(fpath):
      continue
    crc32_info = hk_try_get_crc32_info(fn, crc32_dict)
    if crc32_info == None:
      write_log("[ignore] %s" % fpath)
    else:
      calc_crc32 = hk_calc_crc32_from_file(crc32_bin, fpath)
      if calc_crc32 == crc32_info:
        write_log("[pass] %s" % fpath)
      else:
        write_log("[failure] %s" % fpath)
      

def hk_check_crc32():
  crc32_bin = get_config("crc32_bin")
  root_dir = raw_input("The root directory to start with? ")
  os.path.walk(root_dir, hk_check_crc32_walker, crc32_bin)


def hk_check_ascii_fnames_walker(arg, folder, files):
  write_log("[dir] %s" % folder)
  for fn in files:
    fpath = folder + os.path.sep + fn
    if is_ascii(fpath):
      write_log("[pass] %s" % fpath)
    else:
      write_log("[failure] %s" % fpath)
    

def hk_check_ascii_fnames():
  root_dir = raw_input("The root directory to start with? ")
  os.path.walk(root_dir, hk_check_ascii_fnames_walker, None)

def hk_should_ignore_file(fname, ignore_pattern):
  matched = re.search(ignore_pattern, fname)
  if matched != None:
    return True
  else:
    return False

def hk_should_ignore_crc32(fname, ignore_pattern):
  return hk_should_ignore_file(fname, ignore_pattern)


def hk_write_crc32_walker(args, folder, files):
  crc32_bin, ignore_pattern, new_only = args
  write_log("[dir] %s" % folder)
  crc_f = None
  crc32_dict = {}
  
  if new_only == True:
    crc32_dict_fn = folder + os.path.sep + "housekeeper.crc32"
    crc32_dict = hk_read_crc32_dict(crc32_dict_fn)
    if os.path.exists(crc32_dict_fn):
      write_log("[dict] %s" % crc32_dict_fn)
  
  for fn in files:
    if fn.startswith("housekeeper."):
      # ignore housekeeper's data
      continue
    fpath = folder + os.path.sep + fn
    if os.path.isdir(fpath):
      continue
    if hk_should_ignore_crc32(fn, ignore_pattern):
      write_log("[ignore] %s" % fpath)
      continue
      
    if new_only == True:
      if crc32_dict.has_key(fn):
        write_log("[exists] %s %s" % (crc32_dict[fn], fpath))
        continue
      
    calc_crc32 = hk_calc_crc32_from_file(crc32_bin, fpath)
    write_log("[crc32] %s %s" % (calc_crc32, fpath))
    
    if crc_f == None:
      if new_only == True:
        is_new_file = not os.path.exists(folder + os.path.sep + "housekeeper.crc32")
        crc_f = open(folder + os.path.sep + "housekeeper.crc32", "a")
        if is_new_file:
          crc_f.write("# generated by housekeeper.py, on %s\n" % time.asctime())
          crc_f.write("#\n\n")
        else:
          crc_f.write("\n")
          crc_f.write("# new data updated on %s\n" % time.asctime())
          crc_f.write("#\n\n")
      else:
        crc_f = open(folder + os.path.sep + "housekeeper.crc32", "w")
        crc_f.write("# generated by housekeeper.py, on %s\n" % time.asctime())
        crc_f.write("#\n\n")
      
    crc_f.write("%s %s\n" % (calc_crc32, fn))
    crc_f.flush()
  
  if crc_f != None:
    crc_f.close()

def hk_write_crc32():
  crc32_bin = get_config("crc32_bin")
  ignore_pattern = get_config("crc32_ignore_pattern")
  root_dir = raw_input("The root directory to start with? ")
  new_only = False
  os.path.walk(root_dir, hk_write_crc32_walker, (crc32_bin, ignore_pattern, new_only))

def hk_write_crc32_new_only():
  crc32_bin = get_config("crc32_bin")
  ignore_pattern = get_config("crc32_ignore_pattern")
  root_dir = raw_input("The root directory to start with? ")
  new_only = True
  os.path.walk(root_dir, hk_write_crc32_walker, (crc32_bin, ignore_pattern, new_only))

def hk_util_append_tmp_ext(fpath):
  while True:
    tmp_fpath = "%s.tmp.%d" % (fpath, random.randint(0, 100000000))
    if os.path.exists(tmp_fpath) == False:
      break
  return tmp_fpath

def hk_lowercase_ext():
  root_dir = raw_input("The root directory to start with? ")
  for root, folders, files in os.walk(root_dir):
    for fn in files:
      fpath = os.path.join(root, fn)
      splt = os.path.splitext(fpath)
      if splt[1] != splt[1].lower():
        # rename to a tmp file and rename back
        new_name = splt[0] + splt[1].lower()
        tmp_name = hk_util_append_tmp_ext(fpath)
        print "[rename] %s ==> %s" % (fpath, new_name)
        os.rename(fpath, tmp_name)
        os.rename(tmp_name, new_name)

def hk_rm_empty_dir():
  root_dir = raw_input("The root directory to start with? ")
  ignore_pattern = get_config("rm_empty_dir_ignore_pattern")
  for root, folders, files in os.walk(root_dir):
    if len(folders) > 0:
      continue
    is_empty = True
    for fn in files:
      if hk_should_ignore_file(fn, ignore_pattern) == False:
        is_empty = False
        break
      else:
        print "[ignore] %s" % os.path.join(root, fn)
    if is_empty:
      print "[empty-dir] %s" % root
      shutil.rmtree(root)

def hk_psp_sync_pic():
  psp_root = get_config("psp_root")
  pic_root = get_config("psp_sync_pic.pic_root")
  pic_folders = get_config("psp_sync_pic.folders").split("|")
  convert_bin = get_config("convert_bin")
  
  # check if really a psp dir
  if os.path.isdir(psp_root) == False:
    write_log("[error] psp_root is not a valid dir: '%s'" % psp_root)
    exit(1)
  psp_root_listing = []
  for item in os.listdir(psp_root):
    psp_root_listing += item.lower(),
  for psp_item in ["picture", "music", "psp", "video"]:
    if psp_item not in psp_root_listing:
      write_log("[error] not a valid psp root: '%s'" % psp_root)
      exit(1)
  
  # start syncing
  for folder in pic_folders:
    write_log("[psp-sync-pic] folder: '%s'" % folder)
    from_dir = os.path.join(pic_root, folder)
    to_dir = os.path.join(psp_root, "Picture", folder)
    hk_make_dirs(to_dir)
    from_dir_ls = os.listdir(from_dir)
    to_dir_ls = os.listdir(to_dir)
    for to_f in to_dir_ls:
      to_f_path = os.path.join(to_dir, to_f)
      if not is_image(to_f):
        continue
      if to_f not in from_dir_ls:
        write_log("[del] %s" % to_f_path)
        os.remove(to_f_path)
    for from_f in from_dir_ls:
      if not is_image(from_f):
        continue
      if from_f not in to_dir_ls:
        from_f_path = os.path.join(from_dir, from_f)
        to_f_path = os.path.join(to_dir, from_f)
        write_log("[add] %s" % from_f)
        hk_exec("%s \"%s\" -resize 1280x800 \"%s\"" % (convert_bin, from_f_path, to_f_path))

def hk_batch_rename():
  path = raw_input("Path?\n")
  filter = raw_input("Regexp filter (for fullname, excluding path, i.e., 'basename.extname')?\n")
  file_list = os.listdir(path)
  match_list = []
  print "list of matched files:"
  for file in file_list:
    if re.search(filter, file):
      match_list += file,
      print file

  print
  print "choices:"
  print "1: rename with increasing id"
  print "2: rename according to a function"
  choice = raw_input()
  if choice == "1":
    print "some hints on renaming pattern:"
    print "%d -> increasing id"
    print "%03d -> increasing id, prepadding by 0"
    print "%% -> % itself"
    print "provide renaming pattern (for basename only):"
    pattern = raw_input()
    print "privide start id[1]:"
    start_id = raw_input()
    if start_id == "":
      start_id = 1
    else:
      start_id = int(start_id)
    print "dry run result (not actually executed):"
    
    dry_run = True
    for dummy_i in range(2):
      counter = start_id
      rollback_list = []
      try:
        for file in match_list:
          old_basename = os.path.basename(file)
          old_spltname = os.path.splitext(old_basename)
          new_basename = (pattern % counter) + old_spltname[1]
          print "%s  --->  %s" % (old_basename, new_basename)
          if dry_run == False:
            os.rename(path + os.path.sep + old_basename, path + os.path.sep + new_basename)
          rollback_list += (old_basename, new_basename),
          counter += 1
      except:
        if dry_run:
          raise # re-throw
        else:
          print "error occured, rolling back..."
          for pair in rollback_list:
            old_basename = pair[0]
            new_basename = pair[1]
            print "(rollback) %s  --->  %s" % (new_basename, old_basename)
            os.rename(path + os.path.sep + new_basename, path + os.path.sep + old_basename)
    
      if dry_run == True:
        raw_input("press ENTER to confirm and execute the action...")
        dry_run = False
      else:
        break
    
  elif choice == "2":
    print "please provide a lambda function f(x, i):"
    print "x: original basename (without ext)"
    print "i: counter (starts from 0)"
    print """eg:\n        "%s_%d" % (x, i)"""
    fun_body = raw_input("lambda function?\n")
    print "dry run result (not actually executed):"
    
    dry_run = True
    for dummy_i in range(2):
      exec "housekeeper_lambda_rename_helper_function = lambda x, i: (%s)" % fun_body
      counter = 0
      rollback_list = []
      try:
        for file in match_list:
          old_basename = os.path.basename(file)
          old_spltname = os.path.splitext(old_basename)
          new_basename = housekeeper_lambda_rename_helper_function(old_spltname[0], counter) + old_spltname[1]
          print "%s  --->  %s" % (old_basename, new_basename)
          if dry_run == False:
            os.rename(path + os.path.sep + old_basename, path + os.path.sep + new_basename)
          rollback_list += (old_basename, new_basename),
          counter += 1
      except:
        if dry_run:
          raise # re-throw
        else:
          print "error occured, rolling back..."
          for pair in rollback_list:
            old_basename = pair[0]
            new_basename = pair[1]
            print "(rollback) %s  --->  %s" % (new_basename, old_basename)
            os.rename(path + os.path.sep + new_basename, path + os.path.sep + old_basename)
    
      if dry_run == True:
        raw_input("press ENTER to confirm and execute the action...")
        dry_run = False
      else:
        break
        
  else:
    print "no such choice: '%s'" % choice

def hk_clean_eject_usb(usb_name):
  mount_folder = "/Volumes/" + usb_name
  if os.path.isdir(mount_folder) == False:
    print "USB drive not found: '%s'" % (mount_folder)
    exit(1)
  for cruft in [".DS_Store", ".fseventsd", ".Spotlight-V100", ".Trashes"]:
    cruft_path = os.path.join(mount_folder, cruft)
    if os.path.exists(cruft_path):
      if os.path.isdir(cruft_path):
        print "[rm-dir] %s" % cruft_path
        try:
          shutil.rmtree(cruft_path)
        except:
          traceback.print_exc()
      else:
        print "[rm-file] %s" % cruft_path
        os.remove(cruft_path)
  hk_exec("diskutil eject \"%s\"" % usb_name)


def has_highres_image_set(set_name):
  if set_name in ["moe_imouto", "nekobooru", "konachan", "danbooru"]:
    return True
  else:
    return False

def get_bucket_name(id_in_set):
  BUCKET_SIZE = 100
  bucket_id = id_in_set / BUCKET_SIZE
  bucket_name = "%d-%d" % (bucket_id * BUCKET_SIZE, bucket_id * BUCKET_SIZE + BUCKET_SIZE - 1)
  return bucket_name

def get_highres_image(image_root, set_name, image_id, ext_name):
  if has_highres_image_set(set_name):
    bucket_name = get_bucket_name(int(image_id))
    image_fn = os.path.join(image_root, set_name + "_highres", bucket_name, image_id + "." + ext_name)
    if os.path.exists(image_fn):
      return image_fn
  return None

def split_image_fname(fname):
  image_set = None
  image_id = None
  splt = fname.split()
  image_set = splt[0]
  image_id = splt[1].split(".")[0]
  ext_name = splt[1].split(".")[1]
  return (image_set, image_id, ext_name)

def hk_upgrade_dropbox_pic():
  pic_root = get_config("upgrade_res.pic_root")
  dest_root = get_config("upgrade_res.dest_root")
  pic_folders = get_config("upgrade_res.folders").split("|")
  threshold = int(get_config("upgrade_res.size_threshold_mb")) * 1024 * 1024
  for folder in pic_folders:
    folder_path = os.path.join(dest_root, folder)
    for fn in os.listdir(folder_path):
      fpath = os.path.join(folder_path, fn)
      if os.path.isfile(fpath) == False or is_image(fn) == False:
        continue
      image_set, image_id, ext_name = split_image_fname(fn)
      highres_image = get_highres_image(pic_root, image_set, image_id, ext_name)
      if highres_image == None:
        continue
      else:
        if os.stat(highres_image).st_size > threshold:
          print "[skip] image too big (%.2fMB): '%s'" % (os.stat(highres_image).st_size / 1024.0 /1024.0, highres_image)
        else:
          dest_fn = "%s %s.%s" % (image_set + "_highres", image_id, ext_name)
          write_log("[replace] %s -> %s" % (fn, dest_fn))
          shutil.copy(highres_image, os.path.join(folder_path, dest_fn))
          os.remove(fpath)

def hk_help():
  print "housekeeper.py: helper script to manage my important collections"
  print "usage: housekeeper.py <command>"
  print "available commands:"
  print
  print "  batch-rename            batch rename files under a folder"
  print "  check-ascii-fnames      make sure all file has ascii-only name"
  print "  check-crc32             check file integrity by crc32"
  print "  clean-eject-usb <name>  cleanly eject usb drives (cleans .Trash, .SpotLight folders)"
  print "  help                    display this info"
  print "  lowercase-ext           make sure file extensions are lower case"
  print "  psp-sync-pic            sync images to psp"
  print "  rm-empty-dir            remove empty dir"
  print "  upgrade-dropbox-pic     update dropbox photos folder, prefer highres pictures"
  print "  write-crc32             write crc32 data in every directory, overwrite old crc32 files"
  print "  write-crc32-new-only    write crc32 data in every directroy, new files only"
  print
  print "author: Santa Zhang (santa1987@gmail.com)"

if __name__ == "__main__":
  if len(sys.argv) == 1 or sys.argv[1] == "help":
    hk_help()
  elif sys.argv[1] == "batch-rename":
    hk_batch_rename()
  elif sys.argv[1] == "check-crc32":
    hk_check_crc32()
  elif sys.argv[1] == "check-ascii-fnames":
    hk_check_ascii_fnames()
  elif sys.argv[1] == "clean-eject-usb":
    if len(sys.argv) < 3:
      print "usage: housekeeper.py clean-eject-usb <usb_name>"
      exit(0)
    hk_clean_eject_usb(sys.argv[2])
  elif sys.argv[1] == "lowercase-ext":
    hk_lowercase_ext()
  elif sys.argv[1] == "psp-sync-pic":
    hk_psp_sync_pic()
  elif sys.argv[1] == "rm-empty-dir":
    hk_rm_empty_dir()
  elif sys.argv[1] == "upgrade-dropbox-pic":
    hk_upgrade_dropbox_pic()
  elif sys.argv[1] == "write-crc32":
    hk_write_crc32()
  elif sys.argv[1] == "write-crc32-new-only":
    hk_write_crc32_new_only()
  else:
    print "command '%s' not understood, see 'housekeeper.py help' for more info" % sys.argv[1]
