#!/usr/bin/env python

# One script to manage my important collections.
#
# Author: Santa Zhang (santa1987@gmail.com)
#

import sys
import os
import re
import time
import random
import shutil
from utils import *

def hk_read_crc32_dict(crc32_dict_fn):
  crc32_dict = {}
  if os.path.exists(crc32_dict_fn):
    f = open(crc32_dict_fn)
    for line in f.readlines():
      line = line.strip()
      if line.startswith(";") or line.startswith("#") or line == "":
        continue
      idx = line.find(" ")
      if idx < 0:
        continue
      crc32_dict[line[(idx + 1):]] = line[:idx]
    f.close()
  return crc32_dict

# if return None, then no info
# first try to get data from dict
# if not found, then get data from fname
def hk_try_get_crc32_info(fname, crc32_dict):
  if crc32_dict.has_key(fname):
    return crc32_dict[fname]
  splt = re.split("\[|\]|\(|\)|_", fname)
  for sp in splt:
    if len(sp) == 8 and is_hex(sp):
      return sp
  return None

def hk_calc_crc32_from_file(crc32_bin, fpath):
  crc = None
  cmd = "%s \"%s\"" % (crc32_bin, fpath)
  pipe = os.popen(cmd)
  crc = pipe.readlines()[0].split()[0]
  pipe.close()
  if crc == None:
    raise Exception("Failed to calc crc32 for '%s'! Binary is '%s'." % (fpath, crc32_bin))
  return crc

def hk_check_crc32_walker(crc32_bin, folder, files):
  write_log("[dir] %s" % folder)
  crc32_dict_fn = folder + os.path.sep + "housekeeper.crc32"
  crc32_dict = hk_read_crc32_dict(crc32_dict_fn)
  if os.path.exists(crc32_dict_fn):
    write_log("[dict] %s" % crc32_dict_fn)
    
  for fn in files:
    if fn.startswith("housekeeper."):
      # ignore housekeeper's data
      continue
    fpath = folder + os.path.sep + fn
    if os.path.isdir(fpath):
      continue
    crc32_info = hk_try_get_crc32_info(fn, crc32_dict)
    if crc32_info == None:
      write_log("[ignore] %s" % fpath)
    else:
      calc_crc32 = hk_calc_crc32_from_file(crc32_bin, fpath)
      if calc_crc32 == crc32_info:
        write_log("[pass] %s" % fpath)
      else:
        write_log("[failure] %s" % fpath)
      

def hk_check_crc32():
  crc32_bin = get_config("crc32_bin")
  root_dir = raw_input("The root directory to start with? ")
  os.path.walk(root_dir, hk_check_crc32_walker, crc32_bin)


def hk_check_ascii_fnames_walker(arg, folder, files):
  write_log("[dir] %s" % folder)
  for fn in files:
    fpath = folder + os.path.sep + fn
    if is_ascii(fpath):
      write_log("[pass] %s" % fpath)
    else:
      write_log("[failure] %s" % fpath)
    

def hk_check_ascii_fnames():
  root_dir = raw_input("The root directory to start with? ")
  os.path.walk(root_dir, hk_check_ascii_fnames_walker, None)

def hk_should_ignore_file(fname, ignore_pattern):
  matched = re.search(ignore_pattern, fname)
  if matched != None:
    return True
  else:
    return False

def hk_should_ignore_crc32(fname, ignore_pattern):
  return hk_should_ignore_file(fname, ignore_pattern)


def hk_write_crc32_walker(args, folder, files):
  crc32_bin, ignore_pattern, new_only = args
  write_log("[dir] %s" % folder)
  crc_f = None
  crc32_dict = {}
  
  if new_only == True:
    crc32_dict_fn = folder + os.path.sep + "housekeeper.crc32"
    crc32_dict = hk_read_crc32_dict(crc32_dict_fn)
    if os.path.exists(crc32_dict_fn):
      write_log("[dict] %s" % crc32_dict_fn)
  
  for fn in files:
    if fn.startswith("housekeeper."):
      # ignore housekeeper's data
      continue
    fpath = folder + os.path.sep + fn
    if os.path.isdir(fpath):
      continue
    if hk_should_ignore_crc32(fn, ignore_pattern):
      write_log("[ignore] %s" % fpath)
      continue
      
    if new_only == True:
      if crc32_dict.has_key(fn):
        write_log("[exists] %s %s" % (crc32_dict[fn], fpath))
        continue
      
    calc_crc32 = hk_calc_crc32_from_file(crc32_bin, fpath)
    write_log("[crc32] %s %s" % (calc_crc32, fpath))
    
    if crc_f == None:
      if new_only == True:
        is_new_file = not os.path.exists(folder + os.path.sep + "housekeeper.crc32")
        crc_f = open(folder + os.path.sep + "housekeeper.crc32", "a")
        if is_new_file:
          crc_f.write("# generated by housekeeper.py, on %s\n" % time.asctime())
          crc_f.write("#\n\n")
        else:
          crc_f.write("\n")
          crc_f.write("# new data updated on %s\n" % time.asctime())
          crc_f.write("#\n\n")
      else:
        crc_f = open(folder + os.path.sep + "housekeeper.crc32", "w")
        crc_f.write("# generated by housekeeper.py, on %s\n" % time.asctime())
        crc_f.write("#\n\n")
      
    crc_f.write("%s %s\n" % (calc_crc32, fn))
    crc_f.flush()
  
  if crc_f != None:
    crc_f.close()

def hk_write_crc32():
  crc32_bin = get_config("crc32_bin")
  ignore_pattern = get_config("crc32_ignore_pattern")
  root_dir = raw_input("The root directory to start with? ")
  new_only = False
  os.path.walk(root_dir, hk_write_crc32_walker, (crc32_bin, ignore_pattern, new_only))

def hk_write_crc32_new_only():
  crc32_bin = get_config("crc32_bin")
  ignore_pattern = get_config("crc32_ignore_pattern")
  root_dir = raw_input("The root directory to start with? ")
  new_only = True
  os.path.walk(root_dir, hk_write_crc32_walker, (crc32_bin, ignore_pattern, new_only))

def hk_util_append_tmp_ext(fpath):
  while True:
    tmp_fpath = "%s.tmp.%d" % (fpath, random.randint(0, 100000000))
    if os.path.exists(tmp_fpath) == False:
      break
  return tmp_fpath

def hk_lowercase_ext():
  root_dir = raw_input("The root directory to start with? ")
  for root, folders, files in os.walk(root_dir):
    for fn in files:
      fpath = os.path.join(root, fn)
      splt = os.path.splitext(fpath)
      if splt[1] != splt[1].lower():
        # rename to a tmp file and rename back
        new_name = splt[0] + splt[1].lower()
        tmp_name = hk_util_append_tmp_ext(fpath)
        print "[rename] %s ==> %s" % (fpath, new_name)
        os.rename(fpath, tmp_name)
        os.rename(tmp_name, new_name)

def hk_rm_empty_dir():
  root_dir = raw_input("The root directory to start with? ")
  ignore_pattern = get_config("rm_empty_dir_ignore_pattern")
  for root, folders, files in os.walk(root_dir):
    if len(folders) > 0:
      continue
    is_empty = True
    for fn in files:
      if hk_should_ignore_file(fn, ignore_pattern) == False:
        is_empty = False
        break
      else:
        print "[ignore] %s" % os.path.join(root, fn)
    if is_empty:
      print "[empty-dir] %s" % root
      shutil.rmtree(root)

def hk_help():
  print "housekeeper.py: helper script to manage my important collections"
  print "usage: housekeeper.py <command>"
  print "available commands:"
  print
  print "  check-ascii-fnames      make sure all file has ascii-only name"
  print "  check-crc32             check file integrity by crc32"
  print "  help                    display this info"
  print "  lowercase-ext           make sure file extensions are lower case"
  print "  rm-empty-dir            remove empty dir"
  print "  write-crc32             write crc32 data in every directory, overwrite old crc32 files"
  print "  write-crc32-new-only    write crc32 data in every directroy, new files only"
  print
  print "author: Santa Zhang (santa1987@gmail.com)"

if __name__ == "__main__":
  if len(sys.argv) == 1 or sys.argv[1] == "help":
    hk_help()
  elif sys.argv[1] == "check-crc32":
    hk_check_crc32()
  elif sys.argv[1] == "check-ascii-fnames":
    hk_check_ascii_fnames()
  elif sys.argv[1] == "lowercase-ext":
    hk_lowercase_ext()
  elif sys.argv[1] == "rm-empty-dir":
    hk_rm_empty_dir()
  elif sys.argv[1] == "write-crc32":
    hk_write_crc32()
  elif sys.argv[1] == "write-crc32-new-only":
    hk_write_crc32_new_only()
  else:
    print "command '%s' not understood, see 'housekeeper.py help' for more info" % sys.argv[1]
